-------------------------------------------------------------------------Dutch National Flag Algorithm (Three-Way Partitioning)---------------------------------------------------------------------------------------
Problem Statement:
Sort an array containing three distinct elements (commonly 0, 1, and 2) in linear time (O(n)) and constant space (O(1)). The goal is to arrange the array so that all 0s come first, followed by 1s, and then 2s.

Use Cases:
Sorting arrays with three unique categories.
Partitioning based on three distinct values.
Approach:
Use three pointers to divide the array into four sections:
Low (low): All elements before low are 0s.
Mid (mid): Current element under consideration.
High (high): All elements after high are 2s.
Unsorted: Elements between mid and high are unsorted.
Algorithm Steps:
Initialize Pointers:
low = 0
mid = 0
high = n - 1 (where n is the length of the array)
Iterate Through the Array:
While mid <= high:
Case 1: If arr[mid] == 0
Swap arr[low] and arr[mid]
Increment both low and mid (low += 1, mid += 1)
Case 2: If arr[mid] == 1
Move to the next element (mid += 1)
Case 3: If arr[mid] == 2
Swap arr[mid] and arr[high]
Decrement high (high -= 1)
Note: Do not increment mid here because the swapped element needs to be evaluated.
Code Example (Python):
python
Copy code
def dutch_national_flag(arr):
    low, mid = 0, 0
    high = len(arr) - 1
    
    while mid <= high:
        if arr[mid] == 0:
            arr[low], arr[mid] = arr[mid], arr[low]
            low += 1
            mid += 1
        elif arr[mid] == 1:
            mid += 1
        else:  # arr[mid] == 2
            arr[mid], arr[high] = arr[high], arr[mid]
            high -= 1
    return arr
# Example Usage
arr = [2, 0, 1, 2, 1, 0]
sorted_arr = dutch_national_flag(arr)
print(sorted_arr)  # Output: [0, 0, 1, 1, 2, 2]
Time and Space Complexity:
Time Complexity: O(n) – Single pass through the array.
Space Complexity: O(1) – In-place sorting without extra space.
Example Walkthrough:
Input: [2, 0, 1, 2, 1, 0]
Initial State:
low = 0, mid = 0, high = 5
Array: [2, 0, 1, 2, 1, 0]
Iteration 1 (mid = 0):
arr[mid] = 2
Swap arr[0] and arr[5] → [0, 0, 1, 2, 1, 2]
Decrement high to 4
mid remains 0 to check the swapped element.
Iteration 2 (mid = 0):
arr[mid] = 0
Swap arr[0] and arr[0] (no change)
Increment low to 1 and mid to 1
Iteration 3 (mid = 1):
arr[mid] = 0
Swap arr[1] and arr[1] (no change)
Increment low to 2 and mid to 2
Iteration 4 (mid = 2):
arr[mid] = 1
Increment mid to 3
Iteration 5 (mid = 3):
arr[mid] = 2
Swap arr[3] and arr[4] → [0, 0, 1, 1, 2, 2]
Decrement high to 3
mid remains 3 to check the swapped element.
Iteration 6 (mid = 3):
arr[mid] = 1
Increment mid to 4
Final Sorted Array: [0, 0, 1, 1, 2, 2]
Key Points:
Three Pointers: low, mid, and high help partition the array into three sections.
In-Place Sorting: No additional space is required; swaps are done within the original array.
Single Pass: Efficiently sorts the array in one traversal.
Handling 2s: When encountering a 2, swap with high and reduce the search space from the end.
Stable Handling: Ensures that all 0s are moved to the front and all 2s to the end, with 1s naturally in the middle.
When to Use:
When you need to sort or partition an array with exactly three distinct elements.
Useful in problems requiring categorization or segregation of elements based on three conditions.
Visual Summary:
vbnet
Copy code
Initial Array: [2, 0, 1, 2, 1, 0]
low = 0, mid = 0, high = 5
Step 1: Swap mid and high (2 ↔ 0)
Array: [0, 0, 1, 2, 1, 2]
low = 0, mid = 0, high = 4
Step 2: Swap mid and low (0 ↔ 0)
Array: [0, 0, 1, 2, 1, 2]
low = 1, mid = 1, high = 4
Step 3: Swap mid and low (0 ↔ 0)
Array: [0, 0, 1, 2, 1, 2]
low = 2, mid = 2, high = 4
Step 4: Move mid (1 is in correct place)
Array: [0, 0, 1, 2, 1, 2]
low = 2, mid = 3, high = 4
Step 5: Swap mid and high (2 ↔ 1)
Array: [0, 0, 1, 1, 2, 2]
low = 2, mid = 3, high = 3
Step 6: Move mid (1 is in correct place)
Final Array: [0, 0, 1, 1, 2, 2]
Tips for Interview:
Understand the Invariant: At any point during the algorithm, everything before low is 0, everything after high is 2, and everything between low and mid is 1.
Edge Cases: Handle arrays with all elements same, already sorted, or not rotated.
Explain Your Steps: Clearly articulate how and why you move the pointers during the interview.
Practice Variations: Sometimes, the problem may involve different values or more complex conditions. Understand how to adapt the three-pointer technique.
Further Reading:
LeetCode Problem - Sort Colors
GeeksforGeeks - Dutch National Flag Problem
------------------------------------------------------------------Reversal Algorithm for Array Rotation (Both Left and Right)-------------------------------------------------------------
Problem: Rotate an array to the left or right by d positions.

Purpose: Efficiently rotate the array using reversals, with minimal space and time complexity.

Steps to Rotate Left by d Positions:
   Reverse the first d elements.
   Reverse the remaining n-d elements.
   Reverse the entire array.
Steps to Rotate Right by d Positions:
   Reverse the last d elements.
   Reverse the first n-d elements.
   Reverse the entire array.
Code Example:
python
Copy code
# Helper function to reverse array from index start to end
def reverse(arr, start, end):
    while start < end:
        arr[start], arr[end] = arr[end], arr[start]
        start += 1
        end -= 1

# Rotate array to the left by d positions
def rotate_left(arr, d):
    n = len(arr)
    d = d % n  # Handle cases where d > n
    reverse(arr, 0, d-1)      # Reverse first d elements
    reverse(arr, d, n-1)      # Reverse remaining elements
    reverse(arr, 0, n-1)      # Reverse the entire array

# Rotate array to the right by d positions
def rotate_right(arr, d):
    n = len(arr)
    d = d % n  # Handle cases where d > n
    reverse(arr, n-d, n-1)    # Reverse last d elements
    reverse(arr, 0, n-d-1)    # Reverse the first n-d elements
    reverse(arr, 0, n-1)      # Reverse the entire array
Time Complexity:
O(n) (Three reversals, each taking O(n) time)
Space Complexity:
O(1) (In-place rotation, no extra space)
Example:
Rotate Left:

Input: [1, 2, 3, 4, 5, 6, 7], d = 3
Output: [4, 5, 6, 7, 1, 2, 3]
Rotate Right:

Input: [1, 2, 3, 4, 5, 6, 7], d = 2
Output: [6, 7, 1, 2, 3, 4, 5]
